<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="SpaceX-inspired Command & Control terminal interface">
  <meta name="theme-color" content="#000000">
  <title>COMMAND & CONTROL | Secure Connection</title>
  <style>
    /* Material Icons font face */
    @font-face {
      font-family: 'Material Icons';
      font-style: normal;
      font-weight: 400;
      src: url('icons/MaterialIcons-Regular.woff2') format('woff2'),
           url('icons/MaterialIcons-Regular.woff') format('woff'),
           url('icons/MaterialIcons-Regular.ttf') format('truetype');
    }

    .material-icons {
      font-family: 'Material Icons';
      font-weight: normal;
      font-style: normal;
      font-size: 24px;  /* Preferred icon size */
      display: inline-block;
      line-height: 1;
      text-transform: none;
      letter-spacing: normal;
      word-wrap: normal;
      white-space: nowrap;
      direction: ltr;
      
      /* Support for all WebKit browsers. */
      -webkit-font-smoothing: antialiased;
      /* Support for Safari and Chrome. */
      text-rendering: optimizeLegibility;
      
      /* Support for Firefox. */
      -moz-osx-font-smoothing: grayscale;
      
      /* Support for IE. */
      font-feature-settings: 'liga';
    }
    
    :root {
      --space-black: #000000;
      --space-dark: #121212;
      --space-blue: #005288;
      --space-blue-light: rgba(0, 82, 136, 0.8);
      --space-white: #ffffff;
      --space-gray: #aaaaaa;
      --space-red: #cc0000;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto Mono', monospace;
      background-color: var(--space-black);
      color: var(--space-white);
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    /* Star background with improved star density */
    .stars {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPgogIDxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNmZmYiIHg9IjEwIiB5PSIxMCIgLz4KICA8cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjZmZmIiB4PSI0MCIgeT0iMzAiIC8+CiAgPHJlY3Qgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0iI2ZmZiIgeD0iNzAiIHk9IjUwIiAvPgogIDxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNmZmYiIHg9IjkwIiB5PSIxMCIgLz4KICA8cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjZmZmIiB4PSIxMjAiIHk9IjMwIiAvPgogIDxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNmZmYiIHg9IjE1MCIgeT0iNzAiIC8+CiAgPHJlY3Qgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0iI2ZmZiIgeD0iMTcwIiB5PSI5MCIgLz4KICA8cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjZmZmIiB4PSIyMTAiIHk9IjEwIiAvPgogIDxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNmZmYiIHg9IjE5MCIgeT0iNTAiIC8+CiAgPHJlY3Qgd2lkdGg9IjEiIGhlaWdodD0iMSIgZmlsbD0iI2ZmZiIgeD0iMjMwIiB5PSI0MCIgLz4KPC9zdmc+') repeat;
      opacity: 0.5;
      z-index: -1;
    }
    
    /* Add a subtle glow effect to the background */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(0, 82, 136, 0.1) 0%, rgba(0, 0, 0, 0) 70%);
      pointer-events: none;
      z-index: -1;
    }
    
    /* Header with SpaceX-like styling */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem 5%;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
    }
    
    /* Add a subtle line under the header */
    header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 1px;
      background: linear-gradient(to right, transparent, var(--space-white), transparent);
    }
    
    .logo {
      font-weight: 700;
      font-size: 1.2rem;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    nav ul {
      display: flex;
      list-style: none;
    }
    
    nav ul li {
      margin-left: 2rem;
    }
    
    nav ul li a {
      color: var(--space-white);
      text-decoration: none;
      font-size: 0.9rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 0;
    }
    
    /* Underline effect for nav links */
    nav ul li a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 1px;
      background-color: var(--space-white);
      transition: width 0.3s;
    }
    
    nav ul li a:hover {
      color: var(--space-white);
    }
    
    nav ul li a:hover::after {
      width: 100%;
    }
    
    /* Hero section with SpaceX-like typography */
    .hero {
      text-align: center;
      padding: 8rem 1rem 4rem;
    }
    
    .hero h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .hero p {
      color: var(--space-gray);
      font-size: 1.1rem;
      max-width: 600px;
      margin: 0 auto;
      letter-spacing: 1px;
    }
    
    /* Features section */
    .features {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      max-width: 1000px;
      margin: 0 auto 4rem;
      padding: 0 1rem;
    }
    
    .feature {
      text-align: center;
      width: 250px;
      margin: 2rem 1rem;
      padding: 1.5rem;
      background-color: rgba(18, 18, 18, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      transition: transform 0.3s, box-shadow 0.3s;
      position: relative;
      cursor: pointer;
    }
    
    .feature.clickable {
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .feature.clickable::after {
      content: '▼';
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 0.8rem;
      opacity: 0.7;
      transition: opacity 0.3s;
    }
    
    .feature.clickable:hover::after {
      opacity: 1;
    }
    
    .feature:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 32px rgba(255, 255, 255, 0.1);
    }
    
    .feature h3 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
      letter-spacing: 1px;
    }
    
    .feature p {
      color: var(--space-gray);
      font-size: 0.9rem;
    }
    
    /* API Model Selector */
    .api-selector {
      position: fixed;
      background-color: rgba(18, 18, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      z-index: 9999;
      display: none;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      animation: fadeIn 0.3s ease-in-out;
      width: 250px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    
    .api-selector.active {
      display: block;
    }
    
    .api-option {
      padding: 1rem;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      transition: background-color 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 0.9rem;
    }
    
    .api-option:last-child {
      border-bottom: none;
    }
    
    .api-option:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    .api-option.selected {
      background-color: rgba(255, 255, 255, 0.15);
      position: relative;
    }
    
    .api-option.selected::after {
      content: '●';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.8rem;
    }
    
    .model-tag {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      margin-top: 0.5rem;
      font-size: 0.8rem;
      letter-spacing: 1px;
      display: none;
    }
    
    .model-tag.active {
      display: inline-block;
      animation: fadeIn 0.3s ease-in-out;
    }
    
    #precision-model.active {
      background-color: rgba(255, 255, 255, 0.15);
      border-left: 2px solid rgba(255, 255, 255, 0.7);
    }
    
    /* Feature with active model styling */
    .feature.active-model {
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    /* Citation styling */
    .citation {
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 0.8rem;
      padding-top: 0.8rem;
      font-size: 0.75rem;
      color: var(--space-gray);
    }
    
    .citation-title {
      font-weight: 700;
      display: block;
      margin-bottom: 0.3rem;
      font-size: 0.75rem;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .citation-link {
      display: block;
      margin-bottom: 0.3rem;
      word-break: break-all;
    }
    
    .citation-item {
      margin-bottom: 0.4rem;
      padding-left: 0.5rem;
      border-left: 2px solid rgba(255, 255, 255, 0.1);
      line-height: 1.4;
    }
    
    .citation-item a {
      color: var(--space-white);
      opacity: 0.8;
      transition: opacity 0.3s;
      text-decoration: underline;
      text-decoration-color: rgba(255, 255, 255, 0.3);
    }
    
    .citation-item a:hover {
      opacity: 1;
      text-decoration-color: var(--space-white);
    }
    
    sup {
      vertical-align: super;
      font-size: 0.7em;
      margin: 0 1px;
      color: var(--space-white);
      opacity: 0.7;
    }
    
    /* Chat interface with improved styling */
    .command-section {
      max-width: 800px;
      margin: 0 auto 5rem;
      padding: 0 1rem;
    }
    
    .command-container {
      background-color: rgba(18, 18, 18, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      transition: height 0.3s ease;
    }
    
    .command-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background-color: rgba(0, 0, 0, 0.3);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .command-header h2 {
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 1px;
    }
    
    .command-header-actions {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    #resize-command,
    #clear-command {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--space-white);
      border: none;
      padding: 0.3rem 0.8rem;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      cursor: pointer;
      transition: background-color 0.3s;
      border-radius: 4px;
    }
    
    #resize-command:hover,
    #clear-command:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    #command-messages {
      height: 400px;
      overflow-y: auto;
      padding: 1.5rem;
      scrollbar-width: thin;
      scrollbar-color: var(--space-white) var(--space-dark);
      transition: height 0.3s ease;
    }
    
    /* Command window expanded state */
    #command-messages.expanded {
      height: 600px;
    }
    
    /* Custom scrollbar */
    #command-messages::-webkit-scrollbar {
      width: 6px;
    }
    
    #command-messages::-webkit-scrollbar-track {
      background: var(--space-dark);
    }
    
    #command-messages::-webkit-scrollbar-thumb {
      background-color: var(--space-white);
      border-radius: 6px;
    }
    
    .command-input {
      display: flex;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    #user-input {
      flex: 1;
      background-color: rgba(0, 0, 0, 0.3);
      border: none;
      color: var(--space-white);
      font-family: 'Roboto Mono', monospace;
      padding: 1rem;
      font-size: 0.85rem;
      outline: none;
      transition: background-color 0.3s;
    }
    
    #user-input:focus {
      background-color: rgba(0, 0, 0, 0.5);
    }
    
    #send-button {
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      border: none;
      padding: 0 1.5rem;
      font-family: 'Roboto Mono', monospace;
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #send-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.5s;
    }
    
    #send-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    #send-button:hover::after {
      left: 100%;
    }
    
    /* Footer with improved styling */
    footer {
      text-align: center;
      padding: 2rem;
      color: var(--space-gray);
      font-size: 0.8rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      letter-spacing: 1px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    /* Loading animation with improved styling */
    .typing-indicator {
      display: inline-flex;
      align-items: center;
      padding: 0.5rem 0;
    }
    
    .typing-indicator span {
      width: 6px;
      height: 6px;
      background-color: var(--space-white);
      border-radius: 50%;
      margin: 0 2px;
      animation: blink 1.4s infinite;
    }
    
    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }
    
    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }
    
    @keyframes blink {
      0%, 60%, 100% { opacity: 0.3; transform: scale(1); }
      30% { opacity: 1; transform: scale(1.5); }
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      header {
        flex-direction: column;
        text-align: center;
        padding: 1rem 5%;
      }
      
      nav ul {
        margin-top: 1rem;
      }
      
      nav ul li {
        margin: 0 0.5rem;
      }
      
      .hero h1 {
        font-size: 2rem;
      }
      
      .hero {
        padding: 4rem 1rem 2rem;
      }
      
      .command-section {
        margin: 0 auto 3rem;
      }
      
      #command-messages {
        height: 350px;
      }
      
      .feature {
        width: 100%;
        margin: 1rem 0;
      }
    }
    
    /* Add a pulsing glow to the command container on focus */
    .command-container:focus-within {
      box-shadow: 0 8px 32px rgba(255, 255, 255, 0.1);
    }
    
    .message {
      margin-bottom: 1rem;
      padding: 0.8rem 1rem;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      animation: fadeIn 0.3s ease-in-out;
      font-size: 0.85rem; /* Reduced font size in command terminal */
      position: relative; /* Required for absolute positioning of action buttons */
    }
    
    /* Message action buttons */
    .message-actions {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      display: none;
      gap: 0.5rem;
    }
    
    .message:hover .message-actions {
      display: flex;
    }
    
    .message-action-btn {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--space-white);
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      opacity: 0.7;
      transition: opacity 0.2s, background-color 0.2s;
    }
    
    .message-action-btn:hover {
      opacity: 1;
      background-color: rgba(255, 255, 255, 0.2);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .user-message {
      background-color: rgba(255, 255, 255, 0.1);
      margin-left: auto;
      color: white;
      border-top-right-radius: 0;
      position: relative;
    }
    
    .api-message {
      background-color: rgba(30, 30, 30, 0.8);
      border-left: 3px solid var(--space-white);
      border-top-left-radius: 0;
      position: relative;
    }
    
    /* Notification styling */
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 0.7rem 1.2rem;
      background-color: rgba(20, 20, 20, 0.9);
      color: var(--space-white);
      border-radius: 4px;
      font-size: 0.85rem;
      transform: translateY(100px);
      opacity: 0;
      transition: transform 0.3s, opacity 0.3s;
      z-index: 9000;
      border-left: 3px solid var(--space-blue);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification.error {
      border-left-color: var(--space-red);
    }
    
    /* Armstrong structured response styling */
    .structured-response {
      margin: 0;
      padding: 0;
      width: 100%;
      animation: fadeIn 0.5s ease-out;
    }
    
    .response-section {
      margin-bottom: 1rem;
      padding-bottom: 0.8rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .response-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .section-title {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 1px;
      margin-bottom: 0.4rem;
      color: var(--space-white);
      text-transform: uppercase;
      background: linear-gradient(90deg, rgba(0, 82, 136, 0.2), transparent);
      padding: 0.3rem 0.5rem;
      border-left: 3px solid var(--space-blue);
    }
    
    .section-content {
      font-size: 0.85rem;
      line-height: 1.5;
      padding: 0 0.5rem;
    }
    
    .section-content p {
      margin-bottom: 0.5rem;
    }
    
    .response-list {
      list-style: none;
      padding: 0;
      margin: 0.5rem 0;
    }
    
    .response-list li {
      position: relative;
      padding-left: 1.2rem;
      margin-bottom: 0.4rem;
      line-height: 1.4;
    }
    
    .response-list li:before {
      content: '•';
      position: absolute;
      left: 0.3rem;
      color: var(--space-blue-light);
    }
    
    /* Web copy option styling */
    .web-copy-option {
      background-color: rgba(0, 82, 136, 0.2);
      color: var(--space-white);
      padding: 0.4rem 0.6rem;
      margin-top: 0.8rem;
      font-size: 0.8rem;
      text-align: right;
      border-radius: 3px;
      float: right;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
      letter-spacing: 1px;
    }
    
    .web-copy-option:hover {
      background-color: rgba(0, 82, 136, 0.4);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    /* MD export option styling */
    .md-export-option {
      background-color: rgba(204, 0, 0, 0.2);
      color: var(--space-white);
      padding: 0.4rem 0.6rem;
      margin-top: 0.8rem;
      margin-right: 0.5rem;
      font-size: 0.8rem;
      text-align: right;
      border-radius: 3px;
      float: right;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
      letter-spacing: 1px;
    }
    
    .md-export-option:hover {
      background-color: rgba(204, 0, 0, 0.4);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .action-buttons-container {
      display: flex;
      justify-content: flex-end;
      flex-direction: row-reverse;
      width: 100%;
      clear: both;
    }
    
    .web-source {
      text-align: right;
      border-bottom: none !important;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="stars"></div>

  <header>
    <div class="logo">SARCASTROPHE</div>
    <nav>
      <ul>
        <li><a href="index.php">HOME</a></li>
        <li><a href="test.html">TERMINAL</a></li>
        <li><a href="about.php">ABOUT</a></li>
        <li><a href="contact.php">CONTACT</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <section class="hero">
      <h1>GO BACK TO YOUR LIFE</h1>
      <p>Repository for bad decisions</p>
    </section>
    
    <section class="features">
      <div class="feature" id="aerospace-medicine">
        <h3>Unfit to Fly (But Doing It Anyway)</h3>
        <p>Remote medical support</p>
        <span class="model-tag" id="current-model"></span>
      </div>
      <div class="feature" id="precision-guesswork">
        <h3>Precision Guesswork Inc.</h3>
        <p>Knowledge vault for coding</p>
        <span class="model-tag" id="precision-model"></span>
      </div>
      <div class="feature">
        <h3>Detailed Yet Completely Useless</h3>
        <p>Backend system for report generation</p>
      </div>
    </section>
    
    <section class="command-section">
      <div class="command-container">
        <div class="command-header">
          <h2>Of course I still hate you</h2>
          <div class="command-header-actions">
            <button id="resize-command" aria-label="Resize terminal">EXPAND</button>
            <button id="clear-command" aria-label="Clear terminal">CLEAR</button>
          </div>
        </div>
        <div id="command-messages">
          <!-- Commands will be added here via JavaScript -->
        </div>
        <div class="command-input">
          <input type="text" id="user-input" placeholder="Press send for disappointment...." aria-label="Command input">
          <button id="send-button" aria-label="Send command">SEND</button>
        </div>
      </div>
    </section>
  </main>

  <footer>
    © 2025 DIEGO MALPICA
  </footer>

  <!-- API selector moved to the body level to ensure it's above everything else -->
  <div class="api-selector" id="api-selector">
    <div class="api-option" data-model="sonar-reasoning-pro">@PPLX R-PRO</div>
    <div class="api-option" data-model="sonar-deep-research">@PPLX-DEEP-R</div>
    <div class="api-option" data-model="armstrong-bubble">ARMSTRONG'S LITTLE BUBBLE</div>
    <div class="api-option" data-model="5mcc">5MCC</div>
  </div>

  <script>
    // DOM Elements
    const commandMessages = document.getElementById('command-messages');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const aerospaceMedicine = document.getElementById('aerospace-medicine');
    const precisionGuesswork = document.getElementById('precision-guesswork');
    const apiSelector = document.getElementById('api-selector');
    const apiOptions = document.querySelectorAll('.api-option');
    const currentModelTag = document.getElementById('current-model');
    const precisionModelTag = document.getElementById('precision-model');
    const clearCommandButton = document.getElementById('clear-command');
    const resizeCommandButton = document.getElementById('resize-command');
    
    // Check if all required DOM elements exist
    if (!commandMessages || !userInput || !sendButton || !apiSelector) {
      console.error('Critical DOM elements missing. Chat functionality may not work properly.');
    }
    
    // Perplexity API Configuration
    const PERPLEXITY_API_ENDPOINT = "https://api.perplexity.ai/chat/completions";
    const PERPLEXITY_API_KEY = "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";
    
    // Flowise API Configuration
    const FLOWISE_API_ENDPOINT = "https://private-4.app.flowiseai.com/api/v1/prediction/";
    const FLOWISE_API_TOKEN = "TbvVxMkNs5R5q2DfwAVTjRtqGrFvz2484HzIyK0Owis";

    // Chatflow IDs
    const CHATFLOW_IDS = {
      "armstrong-bubble": "d0bf0d84-1343-4f3b-a887-780d20f9e3c6",
      "5mcc": "3e400cbb-9c0f-4925-9b4e-d1d51f55d369",
      "drone": "43cfb238-4864-4599-866e-d8ec24235203"
    };
    
    // Model mapping from display names to actual API model names
    const MODEL_MAP = {
      "sonar-reasoning-pro": "sonar-reasoning-pro",
      "sonar-deep-research": "sonar-deep-research",
      "sonar-pro": "sonar-pro",
      "armstrong-bubble": "armstrong-bubble",
      "5mcc": "5mcc"
    };
    
    // Default model
    let currentModel = MODEL_MAP["sonar-reasoning-pro"];
    let isPerplexityMode = false;
    
    // Connection status tracking
    let connectionAttempts = 0;
    const MAX_RETRY_ATTEMPTS = 3;
    let hasConnectionFailed = false;
    
    // Chat history for context
    let commandHistory = [];
    
    // Chat window state
    let isCommandExpanded = false;
    
    // Initialize chat
    document.addEventListener('DOMContentLoaded', () => {
      // Add welcome message
      const welcomeMessage = "Tell me what to mess up next";
      addMessage(welcomeMessage, "api");
      
      // Store welcome message in command history
      commandHistory.push({
        role: "assistant",
        content: welcomeMessage
      });
      
      // Event listeners
      sendButton.addEventListener('click', handleSendMessage);
      userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleSendMessage();
      });
      
      // Aerospace Medicine feature click event (if element exists)
      if (aerospaceMedicine) {
        aerospaceMedicine.addEventListener('click', (e) => {
          toggleApiSelector(e, aerospaceMedicine);
        });
        // Visual indicator for clickable feature
        aerospaceMedicine.classList.add('clickable');
      }
      
      // Precision Guesswork feature click event (if element exists)
      if (precisionGuesswork) {
        precisionGuesswork.addEventListener('click', (e) => {
          e.stopPropagation();
          selectApiModel('sonar-pro');
        });
        // Visual indicator for clickable feature
        precisionGuesswork.classList.add('clickable');
      }
      
      // API selector option click events
      apiOptions.forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          selectApiModel(option.dataset.model);
        });
      });
      
      // Close API selector when clicking elsewhere
      document.addEventListener('click', () => {
        if (apiSelector && apiSelector.classList.contains('active')) {
          apiSelector.classList.remove('active');
        }
      });
      
      // Prevent clicks inside the API selector from closing it
      if (apiSelector) {
        apiSelector.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      }
      
      // Focus input field on load
      userInput.focus();
      
      // Add visual feedback when input is focused
      userInput.addEventListener('focus', () => {
        document.querySelector('.command-container').classList.add('focused');
      });
      
      userInput.addEventListener('blur', () => {
        document.querySelector('.command-container').classList.remove('focused');
      });
      
      // Add clear command button event listener
      if (clearCommandButton) {
        clearCommandButton.addEventListener('click', clearCommands);
      }
      
      // Add resize command button event listener
      if (resizeCommandButton) {
        resizeCommandButton.addEventListener('click', toggleCommandSize);
      }
    });
    
    // Toggle API selector visibility
    function toggleApiSelector(e, featureElement) {
      e.stopPropagation();
      
      // Ensure the API selector exists
      if (!apiSelector) {
        console.error('API selector element not found');
        return;
      }
      
      // Get the position of the feature element
      const featureRect = featureElement.getBoundingClientRect();
      
      // Position the dropdown below the feature element
      apiSelector.style.top = `${featureRect.bottom}px`;
      apiSelector.style.left = `${featureRect.left}px`;
      
      // Toggle visibility
      apiSelector.classList.toggle('active');
    }
    
    // Select API model
    function selectApiModel(model) {
      currentModel = MODEL_MAP[model] || MODEL_MAP["sonar-reasoning-pro"];
      isPerplexityMode = model === "sonar-reasoning-pro" || model === "sonar-deep-research" || model === "sonar-pro";
      
      // Reset connection status when switching models
      connectionAttempts = 0;
      hasConnectionFailed = false;
      
      // Update selected option styling
      apiOptions.forEach(option => {
        if (option.dataset.model === model) {
          option.classList.add('selected');
        } else {
          option.classList.remove('selected');
        }
      });
      
      // Remove active-model class from all features
      document.querySelectorAll('.feature').forEach(feature => {
        feature.classList.remove('active-model');
      });
      
      // Update model tags based on which model is selected
      if (model === 'sonar-pro' && precisionModelTag) {
        // For Precision Guesswork Inc.
        precisionModelTag.textContent = 'ANTI-404';
        precisionModelTag.classList.add('active');
        if (currentModelTag) currentModelTag.classList.remove('active');
        
        // Update the feature card styling
        if (precisionGuesswork) precisionGuesswork.classList.add('active-model');
      } else if (currentModelTag) {
        // For other models under Aerospace Medicine
        if (precisionModelTag) precisionModelTag.classList.remove('active');
        currentModelTag.classList.add('active');
        
        if (model === 'sonar-reasoning-pro') {
          currentModelTag.textContent = '@PPLX R-PRO';
        } else if (model === 'sonar-deep-research') {
          currentModelTag.textContent = '@PPLX-DEEP-R';
        } else if (model === 'armstrong-bubble') {
          currentModelTag.textContent = 'ARMSTRONG';
        } else if (model === '5mcc') {
          currentModelTag.textContent = '5MCC';
        }
        
        // Update the feature card styling
        if (aerospaceMedicine) aerospaceMedicine.classList.add('active-model');
      }
      
      // Close selector
      if (apiSelector) apiSelector.classList.remove('active');
      
      // Clear chat history to ensure we start fresh with the new model
      if (commandMessages) commandMessages.innerHTML = '';
      commandHistory = [];
      
      // Add model selection message to chat
      let modelMessage;
      if (model === 'armstrong-bubble') {
        modelMessage = "Switched to Armstrong's Little Bubble...";
      } else if (model === '5mcc') {
        modelMessage = "Switched to 5MCC - Below Armstrong's Little Bubble";
      } else if (model === 'sonar-pro') {
        modelMessage = "Switched to Precision Guesswork Inc. (Anti-404)";
      } else {
        modelMessage = `Model switched to ${model === 'sonar-reasoning-pro' ? '@PPLX R-PRO' : '@PPLX-DEEP-R'}. Search and regret?`;
      }
      addMessage(modelMessage, "api");
      
      // Store model selection in chat history
      commandHistory.push({
        role: "assistant",
        content: modelMessage
      });
      
      // Scroll to bottom of chat
      scrollToBottom();
      
      // Log current state
      console.log(`Model set to ${currentModel}. Chat history reset.`);
    }
    
    // Handle sending commands
    async function handleSendMessage() {
      const message = userInput.value.trim();
      if (!message) return;
      
      // Add user command to terminal
      addMessage(message, "user");
      
      // Store user command in chat history
      commandHistory.push({
        role: "user",
        content: message
      });
      
      // Clear input field
      userInput.value = "";
      
      // Disable input and button during processing
      userInput.disabled = true;
      sendButton.disabled = true;
      
      // Show typing indicator
      const typingIndicator = showTypingIndicator();
      
      try {
        // Create message container for streaming response
        const messageElement = document.createElement('div');
        messageElement.className = 'message api-message';
        commandMessages.appendChild(messageElement);
        
        let responseText;
        
        // Call API based on current mode and model
        if (isPerplexityMode && !hasConnectionFailed) {
          try {
            responseText = await callPerplexityAPI(message, messageElement);
            // Reset connection attempts on success
            connectionAttempts = 0;
          } catch (error) {
            console.error('Perplexity API error:', error);
            connectionAttempts++;
            
            if (connectionAttempts >= MAX_RETRY_ATTEMPTS) {
              hasConnectionFailed = true;
              addMessage("Connection to Perplexity API failed. Switching to fallback mode.", "api");
              // Try fallback API
              responseText = await streamChatResponse(message, messageElement);
            } else {
              // Show error in the current message element
              messageElement.innerHTML = `Error: ${error.message || 'Failed to connect to Perplexity API'}. Retrying with fallback API...`;
              // Retry with fallback for this request
              responseText = await streamChatResponse(message, messageElement);
            }
          }
        } else if (currentModel === "armstrong-bubble") {
          // Call Armstrong's Little Bubble API
          responseText = await callArmstrongAPI(message, messageElement);
        } else if (currentModel === "5mcc") {
          // Call 5MCC API
          responseText = await call5MCCAPI(message, messageElement);
        } else {
          responseText = await streamChatResponse(message, messageElement);
        }
        
        // Store API response in chat history
        if (responseText) {
          commandHistory.push({
            role: "assistant",
            content: responseText
          });
          
          // Limit chat history to last 10 messages to prevent token overflow
          if (commandHistory.length > 10) {
            commandHistory = commandHistory.slice(commandHistory.length - 10);
          }
        }
        
        // Remove typing indicator
        typingIndicator.remove();
      } catch (error) {
        // Remove typing indicator
        typingIndicator.remove();
        
        // Show error message
        addMessage(`Connection error: ${error.message || 'Unable to connect to server'}. Please try again later.`, "api");
        console.error("API Error:", error);
      } finally {
        // Re-enable input and button
        userInput.disabled = false;
        sendButton.disabled = false;
        userInput.focus();
      }
      
      // Scroll to bottom of chat
      scrollToBottom();
    }
    
    // Call Perplexity API with streaming or fallback to non-streaming
    async function callPerplexityAPI(message, messageElement) {
      try {
        // Try streaming first
        try {
          return await callPerplexityAPIWithStreaming(message, messageElement);
        } catch (streamingError) {
          console.error('Streaming error, falling back to non-streaming:', streamingError);
          return await callPerplexityAPIWithoutStreaming(message, messageElement);
        }
      } catch (error) {
        console.error('All Perplexity API attempts failed:', error);
        throw error;
      }
    }
    
    // Call Perplexity API with streaming
    async function callPerplexityAPIWithStreaming(message, messageElement) {
      try {
        // Set the original text attribute for saving/copying
        messageElement.setAttribute('data-original-text', '');
        
        // Most basic message structure - just system message and current user message
        const messages = [
          {
            role: "system",
            content: "You are an AI assistant specializing in aerospace medicine and remote medical support. Always provide detailed, accurate information with proper citations. Please include a numbered list of sources in a section titled 'Sources:' at the end of your response. Keep responses informative and factual. Your answers should reflect the most current scientific understanding in aerospace medicine."
          },
          {
            role: "user",
            content: message
          }
        ];
        
        console.log("Using simplified message format for Perplexity:", JSON.stringify(messages.map(m => ({ role: m.role, content: m.content.substring(0, 50) + (m.content.length > 50 ? "..." : "") }))));
        
        // Prepare the request with simplified message format
        const requestData = {
          model: currentModel,
          messages: messages,
          stream: true,
          max_tokens: 4000,
          temperature: 0.1,
          top_p: 0.9
        };
        
        // Set timeout for the fetch request to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30-second timeout
        
        const response = await fetch(PERPLEXITY_API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${PERPLEXITY_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestData),
          signal: controller.signal
        });
        
        // Clear the timeout
        clearTimeout(timeoutId);
        
        // Check if response is ok
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Network response error: ${response.status}`, errorText);
          throw new Error(`Network response error: ${response.status} - ${errorText}`);
        }
        
        // Process streaming response
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let responseText = '';
        let fullResponse = '';
        let lastUpdateTime = Date.now();
        
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          // Decode the chunk
          const chunk = decoder.decode(value, { stream: true });
          console.log("Received chunk:", chunk);
          
          try {
            // Handle different response formats
            // For SSE format (data: {...})
            const lines = chunk.split('\n').filter(line => line.trim() !== '');
            
            for (const line of lines) {
              if (line.startsWith('data:')) {
                try {
                  const jsonStr = line.slice(5).trim();
                  // Skip [DONE] message
                  if (jsonStr === '[DONE]') continue;
                  
                  const data = JSON.parse(jsonStr);
                  
                  if (data.choices && data.choices[0]) {
                    if (data.choices[0].delta && data.choices[0].delta.content) {
                      responseText += data.choices[0].delta.content;
                      fullResponse += data.choices[0].delta.content;
                    } else if (data.choices[0].message && data.choices[0].message.content) {
                      responseText = data.choices[0].message.content;
                      fullResponse = responseText;
                    }
                    
                    // Format and update the message in the UI
                    messageElement.innerHTML = formatText(responseText);
                    scrollToBottom();
                    lastUpdateTime = Date.now();
                  }
                } catch (err) {
                  console.error('Error parsing JSON in data line:', err, line);
                }
              } else {
                // Try to parse as direct JSON
                try {
                  const data = JSON.parse(line);
                  
                  if (data.choices && data.choices[0]) {
                    if (data.choices[0].delta && data.choices[0].delta.content) {
                      responseText += data.choices[0].delta.content;
                      fullResponse += data.choices[0].delta.content;
                    } else if (data.choices[0].message && data.choices[0].message.content) {
                      responseText = data.choices[0].message.content;
                      fullResponse = responseText;
                    }
                    
                    // Format and update the message in the UI
                    messageElement.innerHTML = formatText(responseText);
                    scrollToBottom();
                    lastUpdateTime = Date.now();
                  }
                } catch (err) {
                  // Not JSON, skip
                }
              }
            }
            
            // Check for timeout in streaming (no updates for 10 seconds)
            if (Date.now() - lastUpdateTime > 10000) {
              console.warn('Streaming response timeout - no updates for 10 seconds');
              break;
            }
          } catch (e) {
            console.error('Error processing chunk:', e);
          }
        }
        
        // If no text was received, show an error message
        if (!responseText) {
          throw new Error('No response text received from API');
        }
        
        // Process citations and format the response
        return processResponseWithCitations(fullResponse, messageElement);
      } catch (error) {
        console.error('Perplexity streaming API error:', error);
        throw error;
      }
    }
    
    // Call Perplexity API without streaming
    async function callPerplexityAPIWithoutStreaming(message, messageElement) {
      try {
        // Most basic message structure - just system message and current user message
        const messages = [
          {
            role: "system",
            content: "You are an AI assistant specializing in aerospace medicine and remote medical support. Always provide detailed, accurate information with proper citations. Please include a numbered list of sources in a section titled 'Sources:' at the end of your response. Keep responses informative and factual. Your answers should reflect the most current scientific understanding in aerospace medicine."
          },
          {
            role: "user",
            content: message
          }
        ];
        
        console.log("Using simplified message format for Perplexity (non-streaming):", JSON.stringify(messages.map(m => ({ role: m.role, content: m.content.substring(0, 50) + (m.content.length > 50 ? "..." : "") }))));
        
        // Prepare the request with simplified message format
        const requestData = {
          model: currentModel,
          messages: messages,
          stream: false,
          max_tokens: 4000,
          temperature: 0.1,
          top_p: 0.9
        };
        
        // Set timeout for the fetch request to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30-second timeout
        
        const response = await fetch(PERPLEXITY_API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${PERPLEXITY_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestData),
          signal: controller.signal
        });
        
        // Clear the timeout
        clearTimeout(timeoutId);
        
        // Check if response is ok
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`Network response error: ${response.status}`, errorText);
          throw new Error(`Network response error: ${response.status} - ${errorText}`);
        }
        
        // Parse the response
        const responseData = await response.json();
        console.log("Received non-streaming response:", responseData);
        
        if (!responseData.choices || !responseData.choices[0] || !responseData.choices[0].message) {
          throw new Error('Invalid response format from API');
        }
        
        const responseContent = responseData.choices[0].message.content;
        
        // Update the message in the UI
        messageElement.innerHTML = formatText(responseContent);
        scrollToBottom();
        
        // Process citations and format the response
        return processResponseWithCitations(responseContent, messageElement);
      } catch (error) {
        console.error('Perplexity non-streaming API error:', error);
        throw error;
      }
    }
    
    // Process response and handle citations
    function processResponseWithCitations(responseText, messageElement) {
      // Extract and format citations
      const citations = extractCitations(responseText);
      
      if (citations && citations.length > 0) {
        // Create citation section
        const citationSection = document.createElement('div');
        citationSection.className = 'citation';
        
        const citationTitle = document.createElement('span');
        citationTitle.className = 'citation-title';
        citationTitle.textContent = 'SOURCES';
        citationSection.appendChild(citationTitle);
        
        // Add each citation
        citations.forEach(citation => {
          const citationElement = document.createElement('div');
          citationElement.className = 'citation-item';
          
          // Try to determine if the citation text is a URL
          const isUrl = /^https?:\/\//.test(citation.text);
          
          if (isUrl) {
            const link = document.createElement('a');
            link.href = citation.text;
            link.textContent = `[${citation.number}] ${citation.text}`;
            link.className = 'citation-link';
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            citationElement.appendChild(link);
          } else {
            // For text citations, try to extract URLs from the text
            const urlRegex = /(https?:\/\/[^\s\]]+)/g;
            const urls = citation.text.match(urlRegex);
            
            if (urls && urls.length > 0) {
              // If the citation contains URLs, make those clickable
              let citationText = citation.text;
              urls.forEach(url => {
                const cleanUrl = url.replace(/[.,;:)]+$/, '');
                citationText = citationText.replace(
                  url,
                  `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer">${cleanUrl}</a>`
                );
              });
              
              citationElement.innerHTML = `[${citation.number}] ${citationText}`;
            } else {
              // Plain text citation
              citationElement.textContent = `[${citation.number}] ${citation.text}`;
            }
          }
          
          citationSection.appendChild(citationElement);
        });
        
        // First remove any existing citation section
        const existingCitation = messageElement.querySelector('.citation');
        if (existingCitation) {
          existingCitation.remove();
        }
        
        // Append the citation section to the message
        messageElement.appendChild(citationSection);
        
        // Now remove any citation section from the main text to avoid duplication
        const mainContent = messageElement.innerHTML;
        const citationSectionRegex = /<br>(References|Sources|Citations):.+?(?=<div class="citation"|$)/is;
        if (citationSectionRegex.test(mainContent)) {
          messageElement.innerHTML = mainContent.replace(citationSectionRegex, '');
          // Re-append the formatted citation section if it was removed
          if (!messageElement.querySelector('.citation')) {
            messageElement.appendChild(citationSection);
          }
        }
      }
      
      return responseText;
    }
    
    // Format messages for Perplexity API
    function formatMessagesForPerplexity() {
      // Start with system message only
      return [
        {
          role: "system",
          content: "You are an AI assistant specializing in aerospace medicine and remote medical support. Always provide detailed, accurate information with proper citations. Please include a numbered list of sources in a section titled 'Sources:' at the end of your response. Keep responses informative and factual. Your answers should reflect the most current scientific understanding in aerospace medicine."
        }
      ];
    }
    
    // Original streaming chat response for backward compatibility
    async function streamChatResponse(message, messageElement) {
      try {
        // Original API endpoint
        const API_ENDPOINT = "https://private-4.app.flowiseai.com/api/v1/prediction/43cfb238-4864-4599-866e-d8ec24235203";
        const API_TOKEN = "TbvVxMkNs5R5q2DfwAVTjRtqGrFvz2484HzIyK0Owis";
        
        // Prepare the request with chat history for context
        const requestData = {
          question: message,
          streaming: true,
          history: commandHistory.slice(0, -1) // Exclude the most recent user message as it's sent separately
        };
        
        const response = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_TOKEN}`
          },
          body: JSON.stringify(requestData)
        });
    
        // Check if response is ok
        if (!response.ok) {
          throw new Error(`Network response error: ${response.status}`);
        }
    
        // Create a reader from the response body stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let responseText = '';
    
        // Read the stream
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          // Decode the chunk and append to response text
          const chunk = decoder.decode(value, { stream: true });
          
          try {
            // Parse the chunk as JSON
            const lines = chunk.split('\n').filter(line => line.trim() !== '');
            
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonStr = line.slice(5).trim();
                const jsonData = JSON.parse(jsonStr);
                
                if (jsonData.event === 'token') {
                  responseText += jsonData.data;
                  messageElement.innerHTML = formatText(responseText);
                  // Update the original text attribute for proper saving/copying
                  messageElement.setAttribute('data-original-text', responseText);
                  scrollToBottom();
                }
              }
            }
          } catch (e) {
            console.error('Error parsing chunk:', e);
            // If parsing fails, just append the raw chunk
            responseText += chunk;
            // Apply formatting which will strip any XML tags
            messageElement.innerHTML = formatText(responseText);
            messageElement.setAttribute('data-original-text', responseText);
          }
        }
    
        // If no text was received, show an error message
        if (!responseText) {
          messageElement.textContent = "Error: No response from server.";
          messageElement.setAttribute('data-original-text', "Error: No response from server.");
        }
        
        return responseText;
      } catch (error) {
        console.error('Streaming error:', error);
        throw error;
      }
    }
    
    // Add message to chat
    function addMessage(text, sender) {
      const messageElement = document.createElement('div');
      messageElement.className = `message ${sender}-message`;
      
      // Store the original plain text for copying
      messageElement.setAttribute('data-original-text', text);
      
      // Process markdown-like formatting
      const formattedText = formatText(text);
      messageElement.innerHTML = formattedText;
      
      // Add action buttons for API responses (not for user messages)
      if (sender === 'api') {
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'message-actions';
        
        // Copy to clipboard button
        const copyBtn = document.createElement('button');
        copyBtn.className = 'message-action-btn';
        copyBtn.title = 'Copy to clipboard';
        copyBtn.textContent = '📋';
        copyBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          copyToClipboard(messageElement.getAttribute('data-original-text'));
        });
        actionsDiv.appendChild(copyBtn);
        
        // Save as markdown button
        const saveBtn = document.createElement('button');
        saveBtn.className = 'message-action-btn';
        saveBtn.title = 'Save as markdown';
        saveBtn.textContent = '💾';
        saveBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          saveAsMarkdown(messageElement.getAttribute('data-original-text'));
        });
        actionsDiv.appendChild(saveBtn);
        
        messageElement.appendChild(actionsDiv);
        
        // Add event listeners for the action buttons after the message is added to DOM
        setTimeout(() => {
          // Copy-Pasta button event listeners
          const webCopyOptions = messageElement.querySelectorAll('.web-copy-option');
          webCopyOptions.forEach(option => {
            option.addEventListener('click', () => {
              copyToClipboard(messageElement.getAttribute('data-original-text'));
              option.textContent = 'Copied!';
              setTimeout(() => { 
                option.textContent = option.textContent === 'Copied!' ? 'Copy-Pasta' : 'Borrow me that text'; 
              }, 2000);
            });
          });
          
          // Borrow button event listeners (for Markdown export)
          const mdExportOptions = messageElement.querySelectorAll('.md-export-option');
          mdExportOptions.forEach(option => {
            option.addEventListener('click', () => {
              saveAsMarkdown(messageElement.getAttribute('data-original-text'));
              option.textContent = 'Saved!';
              setTimeout(() => { 
                option.textContent = 'Borrow'; 
              }, 2000);
            });
          });
        }, 100);
      }
      
      commandMessages.appendChild(messageElement);
      scrollToBottom();
    }
    
    // Function to copy text to clipboard
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(
        () => {
          // Show a brief success message
          showNotification('Copied to clipboard');
        },
        () => {
          // Show error message if copy fails
          showNotification('Failed to copy. Please try again.', true);
        }
      );
    }
    
    // Function to save text as markdown file
    function saveAsMarkdown(text) {
      // Create a standardized filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `response-${timestamp}.md`;
      
      // Create a blob with the text content
      const blob = new Blob([text], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      
      // Create a download link and trigger it
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      
      // Clean up
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      // Show success notification
      showNotification('Saved as markdown');
    }
    
    // Show notification
    function showNotification(message, isError = false) {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      
      if (isError) {
        notification.classList.add('error');
      }
      
      // Add to document and set timeout to remove
      document.body.appendChild(notification);
      
      // Animation
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);
      
      // Remove after delay
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 2000);
    }
    
    // Format text with enhanced markdown-like syntax
    function formatText(text) {
      if (!text) return '';
      
      // First store the original text for copying/saving
      const originalText = text;
      
      // Check if this is Armstrong's structured format with tags
      if (text.includes('</physiology>') || text.includes('</pathophysiology>') || 
          text.includes('</risk_factors>') || text.includes('</prevention_strategies>')) {
        return formatArmstrongResponse(text);
      }
      
      // Extract and format citations if they exist
      let formattedText = text;
      
      // Remove all XML/HTML tags except for those we explicitly add later
      // This will strip any unexpected XML tags from the Flowise API response
      formattedText = formattedText.replace(/<\/?[^>]+(>|$)/g, " ");
      
      // Replace URLs with clickable links while preserving them as plain text
      formattedText = formattedText.replace(
        /(https?:\/\/[^\s\]]+)/g, 
        function(url) {
          return '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + url + '</a>';
        }
      );
      
      // Standardize reference sections to always use "SOURCES"
      formattedText = formattedText.replace(
        /(References|Citations):/gi,
        'Sources:'
      );
      
      // Escape HTML to prevent markdown rendering and show clean text
      formattedText = formattedText
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        // Restore the URL links we just created
        .replace(/&lt;a href=/g, '<a href=')
        .replace(/&lt;\/a&gt;/g, '</a>');
      
      // Format citation numbers [1], [2], etc.
      formattedText = formattedText.replace(/\[(\d+)\]/g, '<sup>[$1]</sup>');
      
      // Convert line breaks to <br>
      formattedText = formattedText.replace(/\n/g, '<br>');
      
      // Add @Web copy option and Borrow option at the end (for non-Armstrong responses)
      formattedText += '<div class="action-buttons-container"><div class="web-copy-option">Copy-Pasta</div><div class="md-export-option">Borrow</div></div>';
      
      return formattedText;
    }
    
    // Format specialized Armstrong output
    function formatArmstrongResponse(text) {
      // Store original text for copying/saving
      const originalText = text;
      
      // Remove any opening tag at the beginning if present
      let processedText = text.replace(/^<\w+>/, '');
      
      // Create sections from the XML-like tagged content
      const sections = [];
      
      // Extract section content using regex
      const sectionRegex = /<(\w+)>([\s\S]*?)<\/\1>/g;
      let match;
      
      while ((match = sectionRegex.exec(processedText)) !== null) {
        const sectionName = match[1];
        const sectionContent = match[2].trim();
        
        // Format the section title nicely
        let formattedTitle = sectionName
          .replace(/_/g, ' ')
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        // Special cases for title formatting
        if (formattedTitle === 'References') formattedTitle = 'SOURCES';
        
        // Add the section to our collection
        sections.push({
          title: formattedTitle,
          content: sectionContent
        });
      }
      
      // Create formatted HTML output
      let formattedOutput = '<div class="structured-response">';
      
      // Add each section with styling
      sections.forEach(section => {
        let content = section.content;
        
        // Format lists - items that start with • or -
        if (content.includes('• ') || content.match(/^- /m)) {
          const listItems = content.split(/(?:^|\n)(?:•|-) /).filter(Boolean);
          content = '<ul class="response-list">';
          listItems.forEach(item => {
            content += `<li>${item.trim()}</li>`;
          });
          content += '</ul>';
        } else {
          // Format normal paragraphs
          content = '<p>' + content.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>') + '</p>';
        }
        
        // Add the formatted section
        formattedOutput += `
          <div class="response-section">
            <div class="section-title">${section.title}</div>
            <div class="section-content">${content}</div>
          </div>
        `;
      });
      
      // Add @Web copy option and Borrow option at the end
      formattedOutput += `
        <div class="response-section web-source">
          <div class="action-buttons-container">
            <div class="web-copy-option">Borrow me that text</div>
            <div class="md-export-option">Borrow</div>
          </div>
        </div>
      `;
      
      formattedOutput += '</div>';
      
      return formattedOutput;
    }
    
    // Extract citations from the text if available
    function extractCitations(text) {
      if (!text) return null;
      
      // Check if there's a citation/sources/references section
      const citationSectionRegex = /(References|Sources|Citations):\s*([\s\S]+)/i;
      const match = text.match(citationSectionRegex);
      
      if (match && match[2]) {
        // We found a citation section
        const citationText = match[2].trim();
        
        // Extract numbered citations
        const citations = [];
        const citationRegex = /\[?(\d+)\]?\s*(.+?)(?=\[?\d+\]?|$)/g;
        let citationMatch;
        
        while ((citationMatch = citationRegex.exec(citationText)) !== null) {
          citations.push({
            number: citationMatch[1],
            text: citationMatch[2].trim()
          });
        }
        
        // If we found numbered citations, return them
        if (citations.length > 0) {
          return citations;
        }
        
        // If no numbered citations, try to split by lines
        const lines = citationText.split('\n').filter(line => line.trim() !== '');
        if (lines.length > 0) {
          return lines.map((line, index) => ({
            number: index + 1,
            text: line.trim()
          }));
        }
      }
      
      // Extract any URLs from the text if no formal citations were found
      const urlRegex = /(https?:\/\/[^\s\]]+)/g;
      const urls = text.match(urlRegex);
      
      if (urls && urls.length > 0) {
        const uniqueUrls = [...new Set(urls)];
        return uniqueUrls.map((url, index) => ({
          number: index + 1,
          text: url.replace(/[.,;:)]+$/, '')
        }));
      }
      
      return null;
    }
    
    // Show typing indicator
    function showTypingIndicator() {
      const indicatorElement = document.createElement('div');
      indicatorElement.className = 'message api-message';
      
      const typingIndicator = document.createElement('div');
      typingIndicator.className = 'typing-indicator';
      
      // Add the animation dots
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('span');
        typingIndicator.appendChild(dot);
      }
      
      indicatorElement.appendChild(typingIndicator);
      commandMessages.appendChild(indicatorElement);
      
      scrollToBottom();
      return indicatorElement;
    }
    
    // Scroll to bottom of chat
    function scrollToBottom() {
      commandMessages.scrollTop = commandMessages.scrollHeight;
    }
    
    // Clear commands function
    function clearCommands() {
      // Clear command messages from DOM
      commandMessages.innerHTML = '';
      
      // Reset command history
      commandHistory = [];
      
      // Reset connection status
      connectionAttempts = 0;
      hasConnectionFailed = false;
      
      // Add a new welcome message
      const welcomeMessage = "Command history cleared. Enter new command.";
      addMessage(welcomeMessage, "api");
      
      // Store welcome message in command history
      commandHistory.push({
        role: "assistant",
        content: welcomeMessage
      });
      
      // Focus on input
      userInput.focus();
    }
    
    // Toggle command window size
    function toggleCommandSize() {
      isCommandExpanded = !isCommandExpanded;
      
      if (isCommandExpanded) {
        commandMessages.classList.add('expanded');
        resizeCommandButton.textContent = 'COLLAPSE';
      } else {
        commandMessages.classList.remove('expanded');
        resizeCommandButton.textContent = 'EXPAND';
      }
      
      // Scroll to bottom after resize
      scrollToBottom();
    }

    // Add the Armstrong API function
    async function callArmstrongAPI(message, messageElement) {
      try {
        // Armstrong's Little Bubble API endpoint
        const API_ENDPOINT = "https://private-4.app.flowiseai.com/api/v1/prediction/d0bf0d84-1343-4f3b-a887-780d20f9e3c6";
        const API_TOKEN = "TbvVxMkNs5R5q2DfwAVTjRtqGrFvz2484HzIyK0Owis";
        
        // Prepare the request with chat history for context
        const requestData = {
          question: message,
          streaming: true,
          history: commandHistory.slice(0, -1) // Exclude the most recent user message as it's sent separately
        };
        
        // Set the original text attribute for saving/copying
        messageElement.setAttribute('data-original-text', '');
        
        const response = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_TOKEN}`
          },
          body: JSON.stringify(requestData)
        });
    
        // Check if response is ok
        if (!response.ok) {
          throw new Error(`Network response error: ${response.status}`);
        }
    
        // Create a reader from the response body stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let responseText = '';
    
        // Read the stream
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          // Decode the chunk and append to response text
          const chunk = decoder.decode(value, { stream: true });
          
          try {
            // Parse the chunk as JSON
            const lines = chunk.split('\n').filter(line => line.trim() !== '');
            
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonStr = line.slice(5).trim();
                const jsonData = JSON.parse(jsonStr);
                
                if (jsonData.event === 'token') {
                  responseText += jsonData.data;
                  messageElement.innerHTML = formatText(responseText);
                  // Update the original text attribute for proper saving/copying
                  messageElement.setAttribute('data-original-text', responseText);
                  scrollToBottom();
                }
              }
            }
          } catch (e) {
            console.error('Error parsing chunk:', e);
            // If parsing fails, just append the raw chunk
            responseText += chunk;
            // Apply formatting which will strip any XML tags
            messageElement.innerHTML = formatText(responseText);
            messageElement.setAttribute('data-original-text', responseText);
          }
        }
    
        // If no text was received, show an error message
        if (!responseText) {
          messageElement.textContent = "Error: No response from Armstrong's Little Bubble.";
        }
        
        // Process any citations in the response
        return processResponseWithCitations(responseText, messageElement);
      } catch (error) {
        console.error('Armstrong API error:', error);
        throw error;
      }
    }

    // Call 5MCC API
    async function call5MCCAPI(message, messageElement) {
      try {
        // 5MCC API endpoint
        const API_ENDPOINT = `${FLOWISE_API_ENDPOINT}${CHATFLOW_IDS["5mcc"]}`;
        
        // Prepare the request with chat history for context
        const requestData = {
          question: message,
          streaming: true,
          history: commandHistory.slice(0, -1) // Exclude the most recent user message as it's sent separately
        };
        
        // Set the original text attribute for saving/copying
        messageElement.setAttribute('data-original-text', '');
        
        const response = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${FLOWISE_API_TOKEN}`
          },
          body: JSON.stringify(requestData)
        });
    
        // Check if response is ok
        if (!response.ok) {
          throw new Error(`Network response error: ${response.status}`);
        }
    
        // Create a reader from the response body stream
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let responseText = '';
    
        // Read the stream
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            break;
          }
          
          // Decode the chunk and append to response text
          const chunk = decoder.decode(value, { stream: true });
          
          try {
            // Parse the chunk as JSON
            const lines = chunk.split('\n').filter(line => line.trim() !== '');
            
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const jsonStr = line.slice(5).trim();
                const jsonData = JSON.parse(jsonStr);
                
                if (jsonData.event === 'token') {
                  responseText += jsonData.data;
                  messageElement.innerHTML = formatText(responseText);
                  // Update the original text attribute for proper saving/copying
                  messageElement.setAttribute('data-original-text', responseText);
                  scrollToBottom();
                }
              }
            }
          } catch (e) {
            console.error('Error parsing chunk:', e);
            // If parsing fails, just append the raw chunk
            responseText += chunk;
            // Apply formatting which will strip any XML tags
            messageElement.innerHTML = formatText(responseText);
            messageElement.setAttribute('data-original-text', responseText);
          }
        }
    
        // If no text was received, show an error message
        if (!responseText) {
          messageElement.textContent = "Error: No response from 5MCC.";
        }
        
        // Process any citations in the response
        return processResponseWithCitations(responseText, messageElement);
      } catch (error) {
        console.error('5MCC API error:', error);
        throw error;
      }
    }
  </script>
</body>
</html> 